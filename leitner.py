#!/usr/bin/pythonimport sys import codecsimport pickleimport osfrom random import shufflefrom datetime import dateimport datetimetoday=date.today()PassID=1FailID=2AbortID=3DeleteID=4TotalLines=50def setTotalLines():	os.system('clear')	while True:		TotalLines=int(raw_input('Please enter the total number of line'))		for i in range(0,TotalLines):			print(i)		select=raw_input('Is this number ok?(y/n)')		if select.lower()=='y':			return 0	def getFlatDataBase(dataBase):	flatDataBase={}	for thisDate in dataBase.keys():		if type(thisDate)==type(today):			for(boxInc, boxDict) in dataBase[thisDate].items():				for (k,v) in boxDict.items():					flatDataBase[k]=v	return flatDataBase	def loadNewCourse(dataBase):		select=raw_input('Are you sure you want to add the new course?(y/n)')	if not(select.lower()=='y'):		return 0		#Checking if the databse is loaded. if not, load it.	if dataBase['isNotLoaded']:		print("\n\n\nLoading Leitner database file.\nIt may take sometime to load")		try:			dataBaseFile=open("dataBase.db",'rb')			dataBase.update(pickle.load(dataBaseFile))			dataBaseFile.close()		except:			print("error loading database file")			return -1			#Reading the course file	try:		courseFile=codecs.open('courseraw.txt',encoding='utf-8', mode='r')		courseStream=[line.rstrip() for line in courseFile]		courseFile.close()	except:		print("error loading course file")		return -1		if len(courseStream) % 2 ==1:		print("File should have even number of lines")		return -1		#Creating a dictionary from the course file	courseDict={}	for i in range(0,len(courseStream),2):		courseDict[courseStream[i]]=courseStream[i+1]		#checking for duplicated entries	#Did not do it. let there be duplicates		#Adding dictinary into the slot 0 of the leitner database	if today in dataBase.keys():		if 2 in dataBase[today].keys():			dataBase[today][2]=dict(dataBase[today][2].items()+courseDict.items())		else:			dataBase[today][2]={k:v for (k,v) in courseDict.items()}	else:		dataBase[today]={2:{k:v for (k,v) in courseDict.items()}}		#saving all the modifications in the database	try:		print("Backing up the database")		os.system('copy dataBase.db daBase'+str(today)+'_'+'_'.join([s[0:2] for s in str(datetime.datetime.now().time()).split(':')])+'.dB')	except:		print('Error backing up the database')		return -1	#Saving the new datbase into the database file	try:		dataBaseFile=open("dataBase.db",'wb')		pickle.dump(dataBase,dataBaseFile)		dataBaseFile.close()	except:		print("error updating databasefile")		return -1		return 0	def resetDataBase(dataBase):		select=raw_input('Are you sure you want to reset the database?(y/n)')	if not(select.lower()=='y'):		return 0			dataBase={'isNotLoaded':False}	#backingup the database	try:		os.system('copy dataBase.db daBase'+str(today)+'_'+'_'.join([s[0:2] for s in str(datetime.datetime.now().time()).split(':')])+'.dB')	except:		print('Error backing up the database')		return -1	try:		dataBaseFile=open("dataBase.db",'wb')		pickle.dump(dataBase,dataBaseFile)		dataBaseFile.close()	except:		print('Error reseting the databasefile')		return -1	return 0def getExam(boxDict,boxInc):	examResults={k:[AbortID,v] for (k,v) in boxDict.items()}	for (k,v) in boxDict.items():		#English is the question, and spanish is the answer		#If the date is less than a month randomly switch question and answer.		question=[v,k]		if boxInc<25 :			shuffle(question)		os.system('clear')		print(question[0])		for i in range(0,TotalLines):			print(' ')		print(question[1])		passFailAbort=raw_input("Did you pass or failed? Do you want to Abort? (p/f/a)")		if passFailAbort.lower()=='p':			examResults[k]=[PassID,v]		elif passFailAbort.lower()=='f':			examResults[k]=[FailID,v]		elif passFailAbort.lower()=='d':			yesNo=raw_input("Are you sure you want to delete this item from database? (y/n)")			if yesNo.lower()=='y':				examResults[k]=[DeleteID,v]		else:			return examResults			return examResults	def practice(dataBase):		#Checking if the databse is loaded. if not, load it.	if dataBase['isNotLoaded']:		print("\n\n\nLoading Leitner database file.\nIt may take sometime to load")		try:			dataBaseFile=open("dataBase.db",'rb')			dataBase.update(pickle.load(dataBaseFile))			dataBaseFile.close()		except:			print("error loading database file")			return -1	abortExam=False	for thisDate in dataBase.keys():		if(type(thisDate)==type(today)):			if thisDate <= today:				for (boxInc,boxDict) in dataBase[thisDate].items():					if len(boxDict)==0:						dataBase[thisDate].pop(boxInc)						continue					examResults=getExam(boxDict,boxInc)					failDate=date.fromordinal(today.toordinal()+1)					passDate=date.fromordinal(today.toordinal()+boxInc)					failInc=3					if ((boxInc%3)==0):						passInc=boxInc*2					else:						passInc=boxInc*3					if passInc>64:						passDate='YouAreDoneWithThesewords'					if not(passDate in dataBase.keys()):						dataBase[passDate]={passInc:{}}					if not(failDate in dataBase.keys()):						dataBase[failDate]={failInc:{}}					if not(passInc in dataBase[passDate].keys()):						dataBase[passDate][passInc]={}					if not(failInc in dataBase[failDate].keys()):						dataBase[failDate][failInc]={}											for (dictKey,passFailAbortDictValList) in examResults.items():						passFailAbort=passFailAbortDictValList[0]						dictVal=passFailAbortDictValList[1]						if passFailAbort==PassID:							dataBase[passDate][passInc].update({dictKey:dictVal})							dataBase[thisDate][boxInc].pop(dictKey)						if passFailAbort==FailID:							dataBase[failDate][failInc].update({dictKey:dictVal})							dataBase[thisDate][boxInc].pop(dictKey)						if passFailAbort==DeleteID:							dataBase[thisDate][boxInc].pop(dictKey)						if passFailAbort==AbortID:							abortExam=True					if abortExam:						break				if len(dataBase[thisDate])==0:					dataBase.pop(thisDate)		if abortExam:			break	#saving all the modifications in the database	try:		print("Backing up the database")		os.system('copy dataBase.db daBase'+str(today)+'_'+'_'.join([s[0:2] for s in str(datetime.datetime.now().time()).split(':')])+'.dB')	except:		print('Error backing up the database')		return -1	try:		print("Saving chnages into the database")		dataBaseFile=open("dataBase.db",'wb')		pickle.dump(dataBase,dataBaseFile)		dataBaseFile.close()	except:		print('Error storing the databasefile')		return -1		return 0def exportDataBase(dataBase):	if dataBase['isNotLoaded']:		print("\n\n\nLoading Leitner database file.\nIt may take sometime to load")		try:			dataBaseFile=open("dataBase.db",'rb')			dataBase.update(pickle.load(dataBaseFile))			dataBaseFile.close()		except:			print("error loading database file")			return -1			#Reading the course file	try:		courseFile=codecs.open('courseRawExported.txt',encoding='utf-8', mode='w')		for thisDate in dataBase.keys():			if type(thisDate)==type(today):				for(boxInc, boxDict) in dataBase[thisDate].items():					for (k,v) in boxDict.items():						courseFile.write(k + '\n')						courseFile.write(v + '\n')		if 'YouAreDoneWithThesewords' in dataBase.keys():			for(boxInc, boxDict) in dataBase['YouAreDoneWithThesewords'].items():				for (k,v) in boxDict.items():					courseFile.write(k + '\n')					courseFile.write(v + '\n')								courseFile.close()	except:		print("error writing export file ")		return -1	return 0	def getOnlineDataBase(dataBase):	if dataBase['isNotLoaded']:		print("\n\n\nLoading Leitner database file.\nIt may take sometime to load")		try:			dataBaseFile=open("dataBase.db",'rb')			dataBase.update(pickle.load(dataBaseFile))			dataBaseFile.close()		except:			print("error loading database file")			return -1	onlineDataBase={}	IDCounter=0	for thisDate in dataBase.keys():		if type(thisDate)==type(today):			for(boxInc, boxDict) in dataBase[thisDate].items():				for (k,v) in boxDict.items():					onlineDataBase[IDCounter]=[k,v,today,2]					IDCounter+=1	if 'YouAreDoneWithThesewords' in dataBase.keys():		for(boxInc, boxDict) in dataBase['YouAreDoneWithThesewords'].items():			for (k,v) in boxDict.items():				onlineDataBase[IDCounter]=[k,v,today,2]				IDCounter+=1							return onlineDataBasedef exportOnlineDataBase(dataBase):	onlineDataBase=getOnlineDataBase(dataBase)	if onlineDataBase==-1:		return -1	try:		dataBaseFile=open("onlineDataBase.db2",'wb')		pickle.dump(onlineDataBase,dataBaseFile)		dataBaseFile.close()	except:		print("error writing to onlineDataBase.db2 file")		return -1	return 0def repotDataBase(dataBase):	print("This feature is not implemented yet.")	return 0def plotDatabasePlan(dataBase):	if dataBase['isNotLoaded']:		print("\n\n\nLoading Leitner database file.\nIt may take sometime to load")		try:			dataBaseFile=open("dataBase.db",'rb')			dataBase.update(pickle.load(dataBaseFile))			dataBaseFile.close()		except:			print("error loading database file")			return -1	datesData={}	for thisDate in dataBase.keys():		if(type(thisDate)==type(today)):			for (boxInc,boxDict) in dataBase[thisDate].items():				count=len(boxDict.keys())				if thisDate <= today:					if today in datesData.keys():						datesData[today]+=count					else:						datesData[today]=count				else:					if thisDate in datesData.keys():						datesData[thisDate]+=count					else:						datesData[thisDate]=count	print('\n\n=====\n\n')	for thisDate in sorted(datesData):		print ("On "+ str(thisDate) + " Study " + str(datesData[thisDate]) + " words.")	if 'YouAreDoneWithThesewords' in dataBase.keys():		total=0		for (boxInc,boxDict) in dataBase['YouAreDoneWithThesewords'].items():			total+=len(boxDict)		print("words that are done reading them: " +str(total))	selection=raw_input("Press Enter to exit.")		return 0	def main():	dataBase={'isNotLoaded':True}	#Using the following code, the first database file is created.	#resetDataBase=False	#if resetDataBase:	#	dataBase={'isNotLoaded':False}	#	dataBaseFile=open("dataBase.db",'wb')	#	pickle.dump(dataBase,dataBaseFile)	#	dataBaseFile.close()			menu = {}	menu['1']="Load course file into database (courseraw.txt)"	menu['2']="Practice"	menu['3']="Reset Data Base"		menu['4']="Configure totla number of lines on the screen "	menu['5']="ExportDatabase (courseRawExported.txt)"	menu['6']="Show the data base in a tree order"		menu['7']="Show the workload graph"	menu['8']="Export online database (onlineDataBase.db2)"	menu['9']="Exit"		while True:		os.system('clear')		print("\n\n******\n\n"+str(today))		#print(dataBase)		print("\n\n******\n\n")		options=menu.keys()		options.sort()		for entry in options: 			print entry, menu[entry]		selection=raw_input("Please Select:") 		if selection =='1': 			if loadNewCourse(dataBase)!=0:				print('Error loading new course file')				return -1		elif selection == '2': 			if practice(dataBase)!=0:				print('Error During practice could not open the file.')				return -1		elif selection == '3':			if resetDataBase(dataBase)!=0:				print('Error resetting data base.')				return -1			dataBase={'isNotLoaded':False}		elif selection == '4':			setTotalLines()		elif selection == '5':			if exportDataBase(dataBase)!=0:				print('Error exporting data base.')				return -1		elif selection == '6':			if repotDataBase(dataBase)!=0:				print('Error exporting data base.')				return -1		elif selection == '7':			if plotDatabasePlan(dataBase)!=0:				print('Error exporting data base.')				return -1		elif selection == '8':			if exportOnlineDataBase(dataBase)!=0:				print('Error exporting data base.')				return -1		elif selection == '9': 			break		else: 			print "Unknown Option Selected!"	return 0	if __name__=='__main__':	sys.exit(main())	#dataBase={}	#sys.exit(loadNewCourse(dataBase))